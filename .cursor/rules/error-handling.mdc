---
globs: *.ts,*.tsx,**/resolvers/**,**/services/**
description: Error handling and validation patterns
---

# Error Handling & Validation

## Error Handling Principles

* Handle errors **upfront** with **guard clauses**; use **early return**; keep happy path last.
* Avoid deep nesting and unnecessary `else`.
* Create typed error helpers (e.g., `BadInputError`, `AuthError`).
* **Resolvers/services** must log with context (requestId, userId) and return **user-friendly** messages.

## Validation Strategy

* Validation via **zod** (server actions & resolvers).
* Use **narrow types** and `zod` schemas for inputs; never accept `any`.
* Validate all inputs, sanitize outputs where needed.

## Error Types

```ts
// Example: Typed error classes
export class BadInputError extends Error {
  constructor(message: string, public field?: string) {
    super(message)
    this.name = 'BadInputError'
  }
}

export class AuthError extends Error {
  constructor(message: string = 'Authentication required') {
    super(message)
    this.name = 'AuthError'
  }
}

export class NotFoundError extends Error {
  constructor(resource: string, id: string) {
    super(`${resource} with id ${id} not found`)
    this.name = 'NotFoundError'
  }
}
```

## Validation Patterns

```ts
import { z } from 'zod'

const CreateProductSchema = z.object({
  title: z.string().min(1).max(255),
  description: z.string().optional(),
  price: z.number().positive(),
  categoryId: z.string().uuid()
})

export async function createProduct(input: unknown) {
  // Validate upfront
  const validInput = CreateProductSchema.parse(input)
  
  // Guard clauses
  if (!validInput.title.trim()) {
    throw new BadInputError('Title cannot be empty', 'title')
  }
  
  // Continue with business logic...
  return await saveProduct(validInput)
}
```

## Resolver Error Handling

```ts
export const resolvers = {
  Mutation: {
    createProduct: async (_, { input }, { userId }) => {
      try {
        // Authentication check
        if (!userId) throw new AuthError()
        
        // Validation
        const validInput = CreateProductSchema.parse(input)
        
        // Business logic
        return await productService.create(validInput, userId)
      } catch (error) {
        // Log with context
        logger.error('Failed to create product', { 
          error: error.message, 
          userId, 
          input 
        })
        
        // Return user-friendly error
        if (error instanceof BadInputError) {
          throw new Error(`Invalid ${error.field}: ${error.message}`)
        }
        
        throw new Error('Failed to create product')
      }
    }
  }
}
```

## Client Error Patterns

* **React/Next.js:** model expected errors as return values for Server Actions.
* Use `error.tsx`/`global-error.tsx` for error boundaries.
* Show user-friendly messages, log technical details.

## Security Considerations

* Never log secrets, tokens, or PII in error messages.
* Sanitize error messages before sending to client.
* Use generic error messages for security-sensitive operations.